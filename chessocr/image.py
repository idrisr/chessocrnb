# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_image.ipynb (unless otherwise specified).

__all__ = ['toPIL', 'color_to_gray', 'gray_to_bw', 'contourFilter', 'bw_to_contours', 'draw_hough_lines',
           'draw_hough_linesp', 'Lines']

# Cell
import cv2
import numpy as np
import random
from fastai.data.all import *
from fastai.vision.all import *
from pathlib import Path
import PIL
import cv2
import pandas as pd
from functools import partial
from numpy import isclose
from scipy.fft import fft, fftfreq
from PIL import ImageOps

# Cell
def toPIL(f):
    """ decorator to convert numpy return func to PIL Image"""
    def _f(*args, **kwargs):
        return PIL.Image.fromarray(f(*args, **kwargs))
    return _f

# Cell
@toPIL
def color_to_gray(i)->PIL.Image:
    i=np.array(i)
    assert i.ndim==3
    i_gray = cv2.cvtColor(i, cv2.COLOR_BGR2GRAY)
    assert i_gray.ndim==2
    return i_gray

# Cell
@toPIL
def gray_to_bw(i):
    """ threshold image on mean of offset image and """
    i_gray = np.array(i)
    assert i_gray.ndim == 2
    mean = i_gray[20:-20,20:-20].mean()
    thresh, i_bw = cv2.threshold(i_gray, mean, 255, cv2.THRESH_BINARY)
    assert i_bw.ndim == 2
    return i_bw

# Cell
def contourFilter(contour, min_ratio, img_area):
    _,_,w,h = tmp = cv2.boundingRect(contour)
    if w == 0 or h == 0: return -1
    ratio = min(w,h)/float(max(w,h))
    area = cv2.contourArea(contour)
    return ratio > min_ratio and area > 1/100 * img_area

# Cell
@toPIL
def bw_to_contours(i):
    i = np.array(i)
    assert i.ndim==2
    assert is_bw(i)

    contoursB, hierarchy = cv2.findContours(i, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_TC89_KCOS)
    f = partial(contourFilter, min_ratio=0.9, img_area=i.shape[0]*i.shape[1])
    contoursA = list(filter(f, contoursB))

    i_con = np.zeros(i.shape, dtype=np.uint8)
    red = (255, 0, 0)
    for contour in contoursA:
        drawContour(i_con, contour, red, thickness=2)

    thresh, i_con = cv2.threshold(i_con, i_con.ravel().mean(), 255, cv2.THRESH_BINARY)

    return i_con

# Cell
def draw_hough_lines(img, lines):
    for line in lines:
        rho, theta, accum = list(line)
        if isclose(theta, 0.0):
            x1 = 0
            y1 = y2 = int(rho)
            x2 = 4000
        elif isclose(theta, np.pi/2):
            y1 = 0
            y2 = 4000
            x1 = x2 = int(rho)
        else:
            continue
        cv2.line(img, (x1, y1), (x2, y2), (255, 0, 255), 1)
    return img

def draw_hough_linesp(img, lines):
    for line in lines:
        x1, y1, x2, y2 = line
        cv2.line(img, (x1, y1), (x2, y2), (0, 0, 255), 2)
    return img

# Cell
class Lines:
    def __init__(self, img, rho=1, theta=np.pi/4, threshold=1):
        self.lines = cv2.HoughLinesWithAccumulator(image=img, rho=rho, theta=theta, threshold=threshold)
        self.df = pd.DataFrame(self.lines.squeeze(1)[:,1:], index=self.lines.squeeze(1)[:,0], columns=['theta', 'score'])
        self.hsg = self.df[self.df.theta==np.pi/2].reindex(range(0, img.shape[0]), fill_value=0).score
        self.vsg = self.df[self.df.theta==0].reindex(range(0, img.shape[0]), fill_value=0).score

    def _period(self, x):
        N=len(x)
        T=1
        yf = fft(x.to_numpy())
        xf=fftfreq(N, T)[:N//2]
        idx = np.argmax(np.abs(yf[1:N//2]))
        return 1/xf[idx]

    @property
    def vspace(self):
        return self._period(self.vsg)

    @property
    def hspace(self):
        return self._period(self.hsg)

    def show(self):
        fig = plt.figure(figsize=(8, 8))
        gs = fig.add_gridspec(2, 2)
        ax1=fig.add_subplot(gs[0, 0])
        ax1.plot(self.hsg)
        ax1.set_title("horizontal")
        ax1.set_xlim(0, len(self.hsg))
        ax2=fig.add_subplot(gs[0, 1])
        ax2.plot(self.vsg)
        ax2.set_xlim(0, len(self.vsg))
        ax2.set_title("vertical")